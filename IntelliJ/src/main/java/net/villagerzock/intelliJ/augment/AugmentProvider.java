package net.villagerzock.intelliJ.augment;

import com.intellij.openapi.module.Module;
import com.intellij.openapi.module.ModuleUtilCore;
import com.intellij.psi.*;
import com.intellij.psi.augment.PsiAugmentProvider;
import com.intellij.psi.impl.light.LightField;
import com.intellij.psi.impl.light.LightFieldBuilder;
import com.intellij.psi.impl.light.LightMethodBuilder;
import com.intellij.psi.impl.light.LightPsiClassBuilder;
import com.intellij.psi.search.GlobalSearchScope;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.*;

public class AugmentProvider extends PsiAugmentProvider {

    @Override
    protected @NotNull <Psi extends PsiElement> List<Psi> getAugments(@NotNull PsiElement element, @NotNull Class<Psi> type, @Nullable String nameHint) {
        if (!(element instanceof PsiClass owner)) return List.of();
        PsiFile file = owner.getContainingFile();
        if (!(file instanceof PsiJavaFile)) return List.of();
        PsiElementFactory factory = JavaPsiFacade.getElementFactory(owner.getProject());
        if (type == PsiClass.class){
            PsiMethod[] methods = owner.getMethods();
            Map<String, PsiMethod> eventsByName = new LinkedHashMap<>();
            for (PsiMethod m : methods){
                PsiModifierList mods = m.getModifierList();
                for (PsiAnnotation ann : mods.getAnnotations()){
                    PsiJavaCodeReferenceElement ref = ann.getNameReferenceElement();
                    String name = ref == null ? "" : ref.getText();
                    if (name == null) continue;
                    if (name.equals("Event") || name.endsWith(".Event")){
                        eventsByName.put(m.getName(),m);
                        break;
                    }
                }
            }
            List<Psi> out = new ArrayList<>();
            for (PsiMethod m : eventsByName.values()) {
                LightPsiClassBuilder listenerInterface = new LightPsiClassBuilder(owner, "eventListener$" + m.getName()) {
                    @Override
                    public boolean isInterface() {
                        return true;
                    }
                };
                listenerInterface.setNavigationElement(m);
                listenerInterface.setOriginInfo("Generated by @Event");
                listenerInterface.setContainingClass(owner);

                LightMethodBuilder sam = new LightMethodBuilder(listenerInterface.getManager(), m.getName());
                sam.setNavigationElement(m);
                sam.addModifier(PsiModifier.PUBLIC);
                sam.addModifier(PsiModifier.ABSTRACT);

                sam.setMethodReturnType(m.getReturnType());

                for (PsiParameter p : m.getParameterList().getParameters()) {
                    sam.addParameter(p.getName(), p.getType());
                }
                for (PsiClassType ex : m.getThrowsList().getReferencedTypes()) {
                    sam.addException(ex);
                }

                listenerInterface.addMethod(sam);

                out.add((Psi) listenerInterface);
            }
            return out;
        }
        if (type != PsiField.class) return List.of();
        if (!owner.isValid()) return List.of();

        System.out.println("Augmenting...");

        PsiMethod[] methods = owner.getMethods();

        Map<String, PsiMethod> eventsByName = new LinkedHashMap<>();
        for (PsiMethod m : methods){
            PsiModifierList mods = m.getModifierList();
            for (PsiAnnotation ann : mods.getAnnotations()){
                String name = ann.getQualifiedName();
                if (name == null) continue;
                if (name.equals("Event") || name.endsWith(".Event")){
                    eventsByName.put(m.getName(),m);
                    break;
                }
            }
        }

        List<Psi> out = new ArrayList<>();
        PsiManager manager = owner.getManager();

        for (PsiMethod m : eventsByName.values()){
            String baseName = m.getName();
            String generatedTypeName = "eventObject$" + m.getName();

            PsiClass fieldClass;
            LightPsiClassBuilder listenerInterface = new LightPsiClassBuilder(owner, "eventListener$"+m.getName()){
                @Override
                public boolean isInterface() {
                    return true;
                }
            };
            listenerInterface.setNavigationElement(m);
            listenerInterface.setOriginInfo("Generated by @Event");

            LightMethodBuilder sam = new LightMethodBuilder(listenerInterface.getManager(), m.getName());
            sam.setNavigationElement(m);
            sam.addModifier(PsiModifier.PUBLIC);
            sam.addModifier(PsiModifier.ABSTRACT);

            sam.setMethodReturnType(m.getReturnType());

            for (PsiParameter p : m.getParameterList().getParameters()){
                sam.addParameter(p.getName(), p.getType());
            }
            for (PsiClassType ex : m.getThrowsList().getReferencedTypes()) {
                sam.addException(ex);
            }

            listenerInterface.addMethod(sam);

            PsiType listenerType = factory.createType(listenerInterface);

            try {
                LightPsiClassBuilder fieldClassBuilder = new LightPsiClassBuilder(owner, generatedTypeName);
                fieldClass = fieldClassBuilder;
                fieldClassBuilder.setNavigationElement(m);
                fieldClassBuilder.setOriginInfo("Generated by @Event");


                LightMethodBuilder emitBuilder = new LightMethodBuilder(fieldClassBuilder.getManager(), "emit").setMethodReturnType(PsiType.VOID);
                for (PsiParameter p : m.getParameterList().getParameters()){
                    emitBuilder.addParameter(p.getName(), p.getType());
                }
                emitBuilder.setNavigationElement(m);
                emitBuilder.setOriginInfo("Generated by @Event");
                emitBuilder.addModifier(PsiModifier.PUBLIC);
                emitBuilder.addModifier(PsiModifier.ABSTRACT);

                LightMethodBuilder addListenerBuilder = new LightMethodBuilder(fieldClassBuilder.getManager(), "addListener").setMethodReturnType(PsiType.VOID);
                addListenerBuilder.addParameter("listener", listenerType);
                addListenerBuilder.setNavigationElement(m);
                addListenerBuilder.setOriginInfo("Generated by @Event");
                addListenerBuilder.addModifier(PsiModifier.PUBLIC);
                addListenerBuilder.addModifier(PsiModifier.ABSTRACT);

                LightMethodBuilder removeListenerBuilder = new LightMethodBuilder(fieldClassBuilder.getManager(), "removeListener").setMethodReturnType(PsiType.VOID);
                removeListenerBuilder.addParameter("listener", listenerType);
                removeListenerBuilder.setNavigationElement(m);
                removeListenerBuilder.setOriginInfo("Generated by @Event");
                removeListenerBuilder.addModifier(PsiModifier.PUBLIC);

                fieldClassBuilder.addMethod(emitBuilder);
                fieldClassBuilder.addMethod(addListenerBuilder);
                fieldClassBuilder.addMethod(removeListenerBuilder);
            }catch (Throwable ignored){
                fieldClass = PsiType.getJavaLangObject(manager, GlobalSearchScope.allScope(owner.getProject())).resolve();
            }

            PsiType fieldType = factory.createType(fieldClass);
            LightFieldBuilder field = new LightFieldBuilder(manager, baseName, fieldType);
            field.setOriginInfo("Generated by @Event");
            field.setNavigationElement(m);
            field.setContainingClass(owner);

            boolean isStatic = m.hasModifierProperty(PsiModifier.STATIC);
            String access = getAccess(m);
            if (isStatic){
                field.setModifiers(access, PsiModifier.STATIC, PsiModifier.FINAL);
            }else {
                field.setModifiers(access, PsiModifier.FINAL);
            }
            out.add((Psi) field);
        }

        return out;
    }

    private String getAccess(PsiMethod m) {
        if (m.getModifierList().hasModifierProperty(PsiModifier.PUBLIC)){
            return PsiModifier.PUBLIC;
        }
        if (m.getModifierList().hasModifierProperty(PsiModifier.PRIVATE)){
            return PsiModifier.PRIVATE;
        }
        if (m.getModifierList().hasModifierProperty(PsiModifier.PROTECTED)){
            return PsiModifier.PROTECTED;
        }
        return PsiModifier.PACKAGE_LOCAL;
    }
}